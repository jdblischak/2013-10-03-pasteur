<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Control Flow in R</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Control Flow in R</h1>

<h4>Often when we&#39;re coding we want to control the flow of our actions. Control flow is simply the order in which we code and have our statements evaluated. That can be done by setting things to happen only if a condition or a set of conditions are met. Alternatively, we can also set an action to be computed for a particular number of times. There are many ways these can be achieved in R. For conditional statements, the most commonly used approaches are the constructs:</h4>

<pre><code class="r">if (and else)
while
</code></pre>

<h4>Say, for example, that we want R to print a message depending on how a number x relates to 5:</h4>

<pre><code class="r">x &lt;- 5
if (x &gt;= 5) {
    print(paste0(x, &quot; is greater or equal than 5&quot;))
} else {
    print(paste0(x, &quot;is smaller than 5&quot;))
}
</code></pre>

<pre><code>## [1] &quot;5 is greater or equal than 5&quot;
</code></pre>

<h4>We could also have a situation where we want an action to be executed while a condition is being matched:</h4>

<pre><code class="r">x &lt;- 0
vec &lt;- vector()
while (x &lt; 10) {
    vec &lt;- c(vec, x^2)
    x &lt;- x + 1
}
vec
</code></pre>

<pre><code>##  [1]  0  1  4  9 16 25 36 49 64 81
</code></pre>

<h4>Now, and this is very important. When R evaluates the condition inside if and while statements, it is looking for a logical element, i.e., TRUE or FALSE. For example:</h4>

<pre><code class="r">if (4 == 3) {
    &quot;4 equals 3&quot;
}
</code></pre>

<h4>The message was not printed because the condition 4 == 3 is FALSE</h4>

<pre><code class="r">4 == 3
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<h4>R also offers a built-in function that is more intuitive to evaluate conditions.</h4>

<pre><code class="r">mat &lt;- matrix(0:19, 5, 4)
mat &lt;- ifelse(mat &lt; 5, 0, mat)

# OR

mat &lt;- matrix(sample(c(NA, 1:10), 50, replace = TRUE), 5, 10)
mat &lt;- ifelse(is.na(mat), 0, 1)
</code></pre>

<h4>In the first example, ifelse looks for all the conditions there are TRUE in the statement <code>mat &lt; 5</code> and replaces them by the first action (transform in 0), otherwise does the altervative action (keep originals). In this case, I told R to keep the original <code>mat</code> values where the condition did not occur. Similarly, in the second example, I told R to replace all existing numbers with 1 and replace missing values with 0. <em>VERY IMPORTANT</em>: ifelse can be very handy, but for heavy and repetitive tasks, it is considerably slower than regular <code>if</code> and <code>else</code> statements.</h4>

<h4>As above, another way of controlling the flow of actions is to set them to occur for a specific number of times. We achieve that using the command <code>for</code></h4>

<pre><code class="r">salad &lt;- c(&quot;lettuce&quot;, &quot;carrots&quot;, &quot;tomatos&quot;)
amounts &lt;- c(&quot;1 bunch&quot;, &quot;1 package&quot;, &quot;1 bag&quot;)
for (vegetable in seq_along(salad)) {
    print(paste0(&quot;Our salad has &quot;, amounts[vegetable], &quot; of &quot;, salad[vegetable]))
}
</code></pre>

<pre><code>## [1] &quot;Our salad has 1 bunch of lettuce&quot;
## [1] &quot;Our salad has 1 package of carrots&quot;
## [1] &quot;Our salad has 1 bag of tomatos&quot;
</code></pre>

<h4>Notice that at each loop, the index <code>vegetable</code> takes a value following the sequence of the vector salad. During the first loop, vegetable, in this particular case, is going to be 1, then 2, and finally 3.</h4>

<pre><code class="r">for (index in 1:3) {
    print(index)
}
</code></pre>

<pre><code>## [1] 1
## [1] 2
## [1] 3
</code></pre>

<h4>The index can take any name you want (preferably names that do not overlap with existing objects or functions). Conventionally, when we deal with matrices or data.frames, we use the index <code>i</code> to denote rows and the index <code>j</code> to denote columns. Example:</h4>

<pre><code class="r">mat &lt;- matrix(1:4, 2, 2)
mat
</code></pre>

<pre><code>##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
</code></pre>

<pre><code class="r">for (i in 1:nrow(mat)) {
    for (j in 1:ncol(mat)) {
        print(mat[i, j])
    }
}
</code></pre>

<pre><code>## [1] 1
## [1] 3
## [1] 2
## [1] 4
</code></pre>

<h4>At this point you may be wondering if we can mix the different approaches and the answer is yes. For a certain <code>for</code> loop, you may want to compute your action only if a condition is matched.</h4>

<pre><code class="r">set.seed(10)
mat &lt;- matrix(rpois(16, lambda = 11), 4, 4)
mat
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]   11   12   14   13
## [2,]   10    6   13   11
## [3,]    6   10   10    7
## [4,]    8    8   14   13
</code></pre>

<pre><code class="r">for (i in 1:nrow(mat)) {
    for (j in 1:ncol(mat)) {
        if (mat[i, j] &gt;= 10) {
            next
        } else {
            print(paste0(&quot;element at row &quot;, i, &quot;, column &quot;, j, &quot;, is smaller than 5&quot;))
        }
    }
}
</code></pre>

<pre><code>## [1] &quot;element at row 2, column 2, is smaller than 5&quot;
## [1] &quot;element at row 3, column 1, is smaller than 5&quot;
## [1] &quot;element at row 3, column 4, is smaller than 5&quot;
## [1] &quot;element at row 4, column 1, is smaller than 5&quot;
## [1] &quot;element at row 4, column 2, is smaller than 5&quot;
</code></pre>

<h4>Do not worry that much about the the functions <code>set.seed</code> and <code>rpois</code>. All you need to know is that <code>set.seed</code> will allow us to generate the same random numbers in different computers for comparison matters and <code>rpois</code> generates positive integers randomly following a Poisson distribution. Notice that I used <code>next</code> to skip the loop in case the condition was TRUE. You can also use the command <code>break</code> if you want to stop the loop at once.</h4>

<h2>Exercise</h2>

<h3>Step 1: create a matrix called <code>mat.ex</code> with 3 rows and 10 columns using <code>set.seed(20); rpois(30, lambda=12)</code> as values;</h3>

<h3>Step 2: create an empty numeric vector called <code>means</code> with length = ncol(mat.ex)</h3>

<h3>Step 3: loop through the columns of <code>mat.ex</code> and calculate the respective mean values of each column;</h3>

<h3>Step 4: if the mean calculated value is greater than 11, store it in <code>means</code>;</h3>

<h3>Step 5: print vector <code>means</code> without zeros</h3>

<h4>solution:</h4>

<pre><code class="r">set.seed(20)
mat.ex &lt;- matrix(rpois(30, lambda = 12), 3, 10)
means &lt;- vector(mode = &quot;numeric&quot;, length = ncol(mat.ex))
for (j in 1:ncol(mat.ex)) {
    if (mean(mat.ex[, j]) &gt; 11) 
        means[j] &lt;- mean(mat.ex[, j])
}
print(means[means != 0])
</code></pre>

<pre><code>## [1] 14.67 11.33 14.33 12.67 12.00 12.67 11.67 17.00
</code></pre>

<h1>Speeding up using the family apply</h1>

<h4>One of the common features across most R beginners is to think everything as a loop. While this approach is valid and in many cases the fastest solution to think of, sometimes it can be very, very slow. Try the following:</h4>

<pre><code class="r">set.seed(10)
x &lt;- matrix(rpois(500, lambda = 25), 20, 25)
a &lt;- vector(mode = &quot;numeric&quot;, length = length(x))
for (index in 1:ncol(x)) {
    a[index] &lt;- mean(x[, index])
}
</code></pre>

<h4>That took &lt; 1 second to run. Although it was effectively fast, the code was relatively big (5 lines) for its small task. Fortunately, R has a family of loop functions called the <code>apply</code> family, which are slightly different but generally as fast as or faster loops than <code>for</code> loops. For the moment, you do not need to fully understand the detailed differences between a regular <code>for</code> loop and it&#39;s equivalent using the <code>apply</code> family. Let&#39;s replicate the example above using the mother function <code>apply</code>:</h4>

<pre><code class="r">set.seed(10)
x &lt;- matrix(rpois(500, lambda = 25), 20, 25)
a &lt;- apply(x, 2, mean)
</code></pre>

<h4><code>a</code> takes the same values as in the example before, but with much less code (3 lines) which is also simpler. In this case, <code>apply</code> evaluates the object <code>x</code> and then apply the function <code>mean</code> to its 2nd dimension, i.e., columns - dimension=1 would imply rows. <code>apply</code> assumes no margin for dimension for it&#39;s evaluations, so you always have to provide it. There are even more convinient and faster ways to calculate sum or mean of dimensions in a matrix or data.frame.</h4>

<pre><code class="r">set.seed(10)
x &lt;- matrix(rpois(500, lambda = 25), 20, 25)
a &lt;- colMeans(x)  #or colSums or rowMeans or rowSums
</code></pre>

<h4>We can also easily create tables using the function <code>tapply</code> from this same family.</h4>

<pre><code class="r">set.seed(10)
dat &lt;- data.frame(genes = rep(paste0(&quot;gene_&quot;, 1:3), each = 5), species = rep(paste0(&quot;species_&quot;, 
    1:5), 3), gc_content = runif(15), stringsAsFactors = FALSE)
dat &lt;- dat[-nrow(dat), ]
dat
</code></pre>

<pre><code>##     genes   species gc_content
## 1  gene_1 species_1    0.50748
## 2  gene_1 species_2    0.30677
## 3  gene_1 species_3    0.42691
## 4  gene_1 species_4    0.69310
## 5  gene_1 species_5    0.08514
## 6  gene_2 species_1    0.22544
## 7  gene_2 species_2    0.27453
## 8  gene_2 species_3    0.27231
## 9  gene_2 species_4    0.61583
## 10 gene_2 species_5    0.42967
## 11 gene_3 species_1    0.65166
## 12 gene_3 species_2    0.56774
## 13 gene_3 species_3    0.11351
## 14 gene_3 species_4    0.59593
</code></pre>

<h4>Suppose we want to know what the mean gc content per gene is:</h4>

<pre><code class="r">tapply(dat$gc_content, dat$genes, mean)
</code></pre>

<pre><code>## gene_1 gene_2 gene_3 
## 0.4039 0.3636 0.4822
</code></pre>

<h4>Sometimes, you may also have a very big and messy dataset and you want to obtain a table that makes things clearer to see. Say we want, for example, the gc_content of species (rows) X genes (columns).</h4>

<pre><code class="r">tapply(dat$gc_content, list(dat$species, dat$genes), sum)
</code></pre>

<pre><code>##            gene_1 gene_2 gene_3
## species_1 0.50748 0.2254 0.6517
## species_2 0.30677 0.2745 0.5677
## species_3 0.42691 0.2723 0.1135
## species_4 0.69310 0.6158 0.5959
## species_5 0.08514 0.4297     NA
</code></pre>

<h4>It is very important to notice that the last value is a NA, simply because the species 5 did not have gene 3, and therefore no gc content. fortunately, we already know how to get rid of NAs in tables if we want to.</h4>

<pre><code class="r">tab &lt;- tapply(dat$gc_content, list(dat$species, dat$genes), sum)
tab &lt;- ifelse(is.na(tab), 0, tab)  #try also tab[is.na(tab)]  &lt;-  0
</code></pre>

<h4>Finally, you can customize your own functions and tomorrow John is going to teach you how to embed your customized functions inside <code>apply</code> calls.</h4>

<h1>Dealing with lists</h1>

<h4>R offers a very powerful class of objects called lists. A list can virtually contain anything. You can have many data.frames inside a list, or you can mix a vector, a data.frame, any other type of array, other lists, and so on. Example:</h4>

<pre><code class="r">set.seed(10)
our_list &lt;- list(runif(10), matrix(1:10, 2, 5), data.frame(letters = letters, 
    order = 1:26))
class(our_list)
</code></pre>

<pre><code>## [1] &quot;list&quot;
</code></pre>

<pre><code class="r">str(our_list)
</code></pre>

<pre><code>## List of 3
##  $ : num [1:10] 0.5075 0.3068 0.4269 0.6931 0.0851 ...
##  $ : int [1:2, 1:5] 1 2 3 4 5 6 7 8 9 10
##  $ :&#39;data.frame&#39;:    26 obs. of  2 variables:
##   ..$ letters: Factor w/ 26 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5 6 7 8 9 10 ...
##   ..$ order  : int [1:26] 1 2 3 4 5 6 7 8 9 10 ...
</code></pre>

<pre><code class="r">dim(our_list)  #lists do not have dimensions as arrays, thay are measured by their number of elements
</code></pre>

<pre><code>## NULL
</code></pre>

<pre><code class="r">length(our_list)
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">names(our_list)  #create names for our list
</code></pre>

<pre><code>## NULL
</code></pre>

<pre><code class="r">names(our_list) &lt;- c(&quot;random_numbers&quot;, &quot;a_matrix&quot;, &quot;a_dataframe&quot;)
our_list
</code></pre>

<pre><code>## $random_numbers
##  [1] 0.50748 0.30677 0.42691 0.69310 0.08514 0.22544 0.27453 0.27231
##  [9] 0.61583 0.42967
## 
## $a_matrix
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    3    5    7    9
## [2,]    2    4    6    8   10
## 
## $a_dataframe
##    letters order
## 1        a     1
## 2        b     2
## 3        c     3
## 4        d     4
## 5        e     5
## 6        f     6
## 7        g     7
## 8        h     8
## 9        i     9
## 10       j    10
## 11       k    11
## 12       l    12
## 13       m    13
## 14       n    14
## 15       o    15
## 16       p    16
## 17       q    17
## 18       r    18
## 19       s    19
## 20       t    20
## 21       u    21
## 22       v    22
## 23       w    23
## 24       x    24
## 25       y    25
## 26       z    26
</code></pre>

<h4>If we want to extract an element from a list, we use double squared brackets [[]].</h4>

<pre><code class="r">our_list[[1]]
</code></pre>

<pre><code>##  [1] 0.50748 0.30677 0.42691 0.69310 0.08514 0.22544 0.27453 0.27231
##  [9] 0.61583 0.42967
</code></pre>

<pre><code class="r">our_list[[&quot;a_matrix&quot;]]
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    3    5    7    9
## [2,]    2    4    6    8   10
</code></pre>

<pre><code class="r">class(our_list[[1]])
</code></pre>

<pre><code>## [1] &quot;numeric&quot;
</code></pre>

<pre><code class="r">dim(our_list[[2]])
</code></pre>

<pre><code>## [1] 2 5
</code></pre>

<h4>Now that we understand the basics of a list, we can use use the function <code>lapply</code> from the <code>apply</code> family, which is a very powerful tool to loop over vectors and lists. Exmaple:</h4>

<pre><code class="r">list_gcs &lt;- list(gene_a = runif(3), gene_b = runif(3), gene_c = runif(3))
means &lt;- lapply(list_gcs, mean)
class(means)
</code></pre>

<pre><code>## [1] &quot;list&quot;
</code></pre>

<pre><code class="r">names(means)
</code></pre>

<pre><code>## [1] &quot;gene_a&quot; &quot;gene_b&quot; &quot;gene_c&quot;
</code></pre>

<pre><code class="r">means[[1]]  #or means[[&#39;gene_a&#39;]], for example
</code></pre>

<pre><code>## [1] 0.4443
</code></pre>

<pre><code class="r">means
</code></pre>

<pre><code>## $gene_a
## [1] 0.4443
## 
## $gene_b
## [1] 0.4609
## 
## $gene_c
## [1] 0.2383
</code></pre>

<h4>Using <code>our_list</code>, we can also use lapply to quickly explore the classes of our different objects within it.</h4>

<pre><code class="r">lapply(our_list, class)
</code></pre>

<pre><code>## $random_numbers
## [1] &quot;numeric&quot;
## 
## $a_matrix
## [1] &quot;matrix&quot;
## 
## $a_dataframe
## [1] &quot;data.frame&quot;
</code></pre>

<h3>Notice that lapply returns a list as its default behavior. R offers a second function that simplifies the output whenever possible. It&#39;s called <code>sapply</code>, which stands for simplify <code>lapply</code>. If your input is a mtrix, the output will also be coerced into a matrix, if your input is a vector, R will try to coerce the output into a vector as well.</h3>

<pre><code class="r">sap &lt;- sapply(our_list, class)
sap
</code></pre>

<pre><code>## random_numbers       a_matrix    a_dataframe 
##      &quot;numeric&quot;       &quot;matrix&quot;   &quot;data.frame&quot;
</code></pre>

<pre><code class="r">class(sap)
</code></pre>

<pre><code>## [1] &quot;character&quot;
</code></pre>

</body>

</html>

